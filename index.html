<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="utf-8" />
    <title>Viimeistelty kaasupoltin äänillä</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f0f0f0; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; color: #ccc; font-size: 16px; pointer-events: none; }
        /* KORJATTU: Parempi asettelu eri näyttöko'oille */
        #controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box; /* Varmistaa, että padding ei lisää leveyttä */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }
        #buttons { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; background-color: #ffffff; border: 1px solid #cccccc; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: background-color 0.2s, transform 0.1s; }
        button:hover { background-color: #e9e9e9; }
        button:active { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #flame-control-container { display: flex; align-items: center; background-color: rgba(255, 255, 255, 0.9); padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #flame-control-container label { margin-right: 10px; font-weight: 500; color: #333; }
        #flame-slider { width: 200px; }
        #warning { position: absolute; top: 50%; left: 50%; transform: translate(--50%, -50%); background-color: rgba(255, 100, 100, 0.9); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.3); font-size: 18px; text-align: center; z-index: 20; display: none; }
    </style>
</head>
<body>
    <div id="controls-container">
        <div id="flame-control-container">
            <label for="plier-slider">Pihtien avaus:</label>
            <input type="range" id="plier-slider" min="0" max="90" value="0">
            <label style="margin-left:20px;">
                <input type="checkbox" id="plier-move-checkbox" checked>
                Liikuta pihtejä
            </label>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls;
    let pliersRoot = null;
    let leftPart = null;
    let rightPart = null;

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 2, 5);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();
    const light = new THREE.HemisphereLight(0xffffff, 0x888888, 1.5);
    scene.add(light);
    // Lisää kirkas point light metallin kiiltoa varten
    const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
    pointLight.position.set(5, 10, 10);
    scene.add(pointLight);
    // Lisää ambient light, jotta metallipinta ei jää tummaksi
    const ambient = new THREE.AmbientLight(0xffffff, 1.1);
    scene.add(ambient);
        loadModel();
        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('plier-slider').addEventListener('input', onPlierSliderChange);

        // Kosketusohjaus: pinch avaa/sulkee pihdit vain jos valintaruutu on valittu
        let lastPinchDist = null;
        const slider = document.getElementById('plier-slider');
        const plierMoveCheckbox = document.getElementById('plier-move-checkbox');

        // Päivitä OrbitControls zoomaus sallittu/ei sallittu valintaruudun mukaan
        function updateControlsZoom() {
            if (controls) {
                controls.enableZoom = !plierMoveCheckbox.checked;
            }
        }
        plierMoveCheckbox.addEventListener('change', updateControlsZoom);
        updateControlsZoom();

        window.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                lastPinchDist = getPinchDistance(e.touches[0], e.touches[1]);
            }
        }, {passive: false});
        window.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && lastPinchDist !== null) {
                const newDist = getPinchDistance(e.touches[0], e.touches[1]);
                const delta = newDist - lastPinchDist;
                if (plierMoveCheckbox.checked) {
                    // Säädetään sliderin arvoa delta:n perusteella
                    let value = parseFloat(slider.value) + delta * 0.3; // skaalauskerroin
                    value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
                    slider.value = value;
                    onPlierSliderChange({target: slider});
                    lastPinchDist = newDist;
                    e.preventDefault();
                } // muuten pinch toimii vain zoomina (OrbitControls hoitaa)
            }
        }, {passive: false});
        window.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                lastPinchDist = null;
            }
        });
        function getPinchDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx*dx + dy*dy);
        }
    }

    // Pivotit puoliskoille
    let leftPivot = null;
    let rightPivot = null;

    function loadModel() {
        const loader = new GLTFLoader();
        loader.load('pihdit.glb', (gltf) => {
            pliersRoot = gltf.scene;
            scene.add(pliersRoot);
            // Debug: tulosta kaikki objektit konsoliin
            pliersRoot.traverse(obj => {
                console.log('Objekti:', obj.name, obj);
            });
            // Oletetaan, että "vasen" ja "oikea" ovat pääobjektin lapsia
            leftPart = pliersRoot.getObjectByName('vasen');
            rightPart = pliersRoot.getObjectByName('oikea');
            if (!leftPart || !rightPart) {
                console.warn('Vasenta tai oikeaa osaa ei löytynyt!');
                return;
            }
            // Luo pivotit origoon ja siirrä puoliskot niiden alle (älä muuta puoliskojen positionia)
            leftPivot = new THREE.Object3D();
            rightPivot = new THREE.Object3D();
            leftPivot.position.set(0,0,0);
            rightPivot.position.set(0,0,0);
            pliersRoot.add(leftPivot);
            pliersRoot.add(rightPivot);
            leftPivot.add(leftPart);
            rightPivot.add(rightPart);
        }, undefined, (err) => {
            console.error('Virhe GLB-latauksessa:', err);
        });
    }

    function onPlierSliderChange(e) {
        const deg = parseFloat(e.target.value);
        const rad = THREE.MathUtils.degToRad(deg);
        if (leftPivot) leftPivot.rotation.z = rad;
        if (rightPivot) rightPivot.rotation.z = -rad;
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    </script>
</body>
</html>